Easy

Task 1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface ICalculateDistance
{
    void GetDistance(double startX, double startY);
    void GetDistance((double, double) coordinates);
    void GetDistance(string coordinates);
}

public class Point : ICalculateDistance
{
    public double X {  get; set; }
    public double Y { get; set; }

    public Point(double endX, double endY)
    {
        X = endX; 
        Y = endY;
    }
    public Point ((double, double) coordinates)
    {
        X = coordinates.Item1;
        Y = coordinates.Item2;
    }
    public Point (string coordinates)
    {
        X = Convert.ToDouble(coordinates.Split(",")[0]);
        Y = Convert.ToDouble(coordinates.Split(",")[1]);
    }

    public void GetDistance(double startX, double startY)
    {
        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance((double, double) coordinates)
    {
        double startX = coordinates.Item1;
        double startY = coordinates.Item2;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance(string coordinates)
    {
        double startX = Convert.ToDouble(coordinates.Split(",")[0]);
        double startY = Convert.ToDouble(coordinates.Split(",")[1]);

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }

}



public class Program
{

    static void Main()
    {

        Point distance = new Point(5, 5);

        distance.GetDistance("10, 10");
        Console.WriteLine();
        distance.GetDistance((10, 10));
        Console.WriteLine();
        distance.GetDistance(10, 10);

        Console.ReadKey();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface ICalculateDistance
{
    void GetDistance(double startX, double startY);
    void GetDistance((double, double) coordinates);
    void GetDistance(string coordinates);
}
public class Point : ICalculateDistance
{
    public double X {  get; set; }
    public double Y { get; set; }

    public Point(double endX, double endY)
    {
        X = endX; 
        Y = endY;
    }
    public Point ((double, double) coordinates)
    {
        X = coordinates.Item1;
        Y = coordinates.Item2;
    }
    public Point (string coordinates)
    {
        X = Convert.ToDouble(coordinates.Split(",")[0]);
        Y = Convert.ToDouble(coordinates.Split(",")[1]);
    }

    public void GetDistance(double startX, double startY)
    {
        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance((double, double) coordinates)
    {
        double startX = coordinates.Item1;
        double startY = coordinates.Item2;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance(string coordinates)
    {
        double startX = Convert.ToDouble(coordinates.Split(",")[0]);
        double startY = Convert.ToDouble(coordinates.Split(",")[1]);

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }

    public double GetDistance(int startXcoord, int startYcoord)
    {
        double startX = startXcoord;
        double startY = startYcoord;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        return distance;
    }

}


public class Engine
{
    public string Type { get; set; }

    public Engine(string type) { Type = type; }

    public virtual void Move()
    {
        Console.WriteLine("The ship is moving.");
    }
}

public class ManeuveringEngine : Engine
{
    private Random random = new Random();
    private string[] _movements = new string[] { "→", "←", "↑", "↓" };
    private string _currentMovement;
    public ManeuveringEngine() : base("Maneuvering Engine") { _currentMovement = _movements[2]; }

    public override void Move()
    {
        string randomMovement = _currentMovement;
        while (randomMovement == _currentMovement)
        {
            randomMovement = _movements[random.Next(0, _movements.Length)];
        }

        Console.WriteLine($"{Type}: Ship is rotating from {_currentMovement} to {randomMovement}");
        _currentMovement = randomMovement;
    }
}

public class SustainingEngine : Engine
{
    private double _distance;

    public SustainingEngine() : base("Sustaining Engine") { _distance = 0; }
    public SustainingEngine(double distance) : base("Sustaining Engine") { if (distance > 0) _distance = distance; else _distance = 0; }


    public override void Move()
    {
        while (_distance > 0)
        {
            _distance--;
            if(_distance < 0) _distance = 0;

            Console.WriteLine($"{Type}: Ship is moving. Remaining distance: {_distance}");

        }
    }
}

public class JumpingEngine : Engine
{
    private double _distance;

    public JumpingEngine() : base("Jumping Engine") { _distance = 0; }
    public JumpingEngine(double distance) : base("Jumping Engine") { if (distance > 0) _distance = distance; else _distance = 0; }


    public override void Move()
    {
        while (_distance > 0)
        {
            _distance -= 5;
            if (_distance < 0) _distance = 0;

            Console.WriteLine($"{Type}: Ship is moving. Remaining distance: {_distance}");

        }
    }
}




public class HandleLoop
{
    public static void ActivateMove(List<Engine> engines)
    {
        foreach (Engine engine in engines) engine.Move();
    }
}

public class Program
{

    static void Main()
    {
        Point distance = new Point(5, 5);

        List<Engine> engines = new List<Engine>()
        {
            new ManeuveringEngine(),
            new SustainingEngine(distance.GetDistance(30, 20)),
            new JumpingEngine(distance.GetDistance(30, 20))

        };

        HandleLoop.ActivateMove(engines);

        Console.ReadKey();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Medium

Task 3
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface IShape
{
    void Draw();
}

public class NavigationTable : IShape
{
    private Random random = new Random();
    private int[,] _field;
    private int Size { get; }

    public NavigationTable()
    {
        Size = 20;
        _field = new int[Size, Size];
        PopulateField();
    }


    private void PopulateField()
    {
        // getting min and max size for impassable
        int minImpassable = (int)(Size * Size * 0.05);
        int maxImpassable = (int)(Size * Size * 0.2);
        // randomly chosing between min and max value
        int impassableCounter = random.Next(minImpassable, maxImpassable + 1);

        // filling up all cells with passable value
        ClearField();

        // randomly changing cells to impassable until it reaches the impassable counter
        int counter = 0;

        while (counter < impassableCounter)
        {
            int x = random.Next(0, Size);
            int y = random.Next(0, Size);

            if (_field[x, y] == 0)
            {
                _field[x, y] = 1;
                counter++;
            }
        }
    }

    private void ClearField()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                _field[i, j] = 0;
            }
        }
    }

    public void Draw()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                Console.Write($" {_field[i, j]} ");
            }
            Console.WriteLine();
        }
    }

    public void Move(char direction)
    {
        int newY;
        int newX;

        switch (direction)
        {
            case 'W':
                {
                    newY = -1;
                    newX = 0;
                }
                break;
            case 'A':
                {
                    newY = 0;
                    newX = -1;
                }
                break;
            case 'S':
                {
                    newY = 1;
                    newX = 0;
                }
                break;
            case 'D':
                {
                    newY = 0;
                    newX = 1;
                }
                break;
            default:
                {
                    newY = 0;
                    newX = 0;
                }
                break;
        }

        // storing the current positions in a list
        List<(int y, int x)> currentPositions = new List<(int y, int x)>();

        for(int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                if (_field[i, j] == 1)
                {
                    currentPositions.Add((i, j));
                }
            }
        }

        // clearing the field
        ClearField();

        foreach ((int y, int x) in currentPositions)
        {
            int nextY = y + newY;
            int nextX = x + newX;

            if (nextY < 0) nextY = Size-1;
            if (nextX < 0) nextX = Size-1;
            if (nextY > Size - 1) nextY = 0;
            if (nextX > Size - 1) nextX = 0;

            _field[nextY, nextX] = 1;

        }





    }


}





public class HandleLoop
{

    private NavigationTable _table;

    public HandleLoop()
    {
        _table = new NavigationTable();
    }

    public void Play()
    {
        bool play = true;

            while (play)
            {

                Console.Clear();

                _table.Draw();

                Console.Write("Next direction: ");
                char direction = Convert.ToChar(Console.ReadLine().Trim().ToUpper());

                if (direction == 'Q') play = false;

                _table.Move(direction);

            }
    }


}

class Program
{
    static void Main()
    {
        HandleLoop loop = new HandleLoop();

        loop.Play();

        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 4
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

public abstract class Ship
{
    public int FuelTankSize {  get; }
    public int CurrentFuelLevel { get; set; }
    public List<Engine> Engines { get; set; }

    public Ship(int fuelTankSize, int fuelLevel, List<Engine> engines)
    {
        FuelTankSize = fuelTankSize;
        Engines = engines;
        CurrentFuelLevel = fuelLevel;
    }

    public abstract void ChangeFuelLevel();
}

public class Proud : Ship
{
    public Proud(int fuelTankSize, int fuelLevel, List<Engine> engines) : base(fuelTankSize, fuelLevel, engines) { }

    public override void ChangeFuelLevel()
    {
        foreach (Engine engine in Engines)
        {
            if (engine.Type == "Maneuvering")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per turn.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Maneuvering not possible: Insufficient fuel level.");
            }
            else if (engine.Type == "Sustaining")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per unit of distance traveled.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Insufficient fuel.");
            }
            else if (engine.Type == "Jumping")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per jump.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Jumping not possible: Insufficient fuel level.");
            }
        }
    }
}

public class Engine
{
    public string Type { get; }
    public int Consumption { get; }
    public Engine(string type)
    {
        Type = type;

        if (type == "Jumping") Consumption = 100;
        else if (type == "Sustaining") Consumption = 10;
        else Consumption = 1;
    }
}




public class HandleTask
{
    private Proud _proud;
    private List<Engine> _engines;

    public HandleTask()
    {
        _engines = new List<Engine>();
        CreateEngines();
        _proud = new Proud(200, 150, _engines);
    }

    private void CreateEngines()
    {
        _engines.Add(new Engine("Maneuvering"));
        _engines.Add(new Engine("Sustaining"));
        _engines.Add(new Engine("Jumping"));
        _engines.Add(new Engine("Jumping"));
    }

    public void CallChangeFuelLevel()
    {
        _proud.ChangeFuelLevel();
    }


}

class Program
{
    static void Main()
    {
        HandleTask task = new HandleTask();

        task.CallChangeFuelLevel();

        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Hard

Task 5
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

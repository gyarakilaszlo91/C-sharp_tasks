Easy

Task 1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface ICalculateDistance
{
    void GetDistance(double startX, double startY);
    void GetDistance((double, double) coordinates);
    void GetDistance(string coordinates);
}

public class Point : ICalculateDistance
{
    public double X {  get; set; }
    public double Y { get; set; }

    public Point(double endX, double endY)
    {
        X = endX; 
        Y = endY;
    }
    public Point ((double, double) coordinates)
    {
        X = coordinates.Item1;
        Y = coordinates.Item2;
    }
    public Point (string coordinates)
    {
        X = Convert.ToDouble(coordinates.Split(",")[0]);
        Y = Convert.ToDouble(coordinates.Split(",")[1]);
    }

    public void GetDistance(double startX, double startY)
    {
        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance((double, double) coordinates)
    {
        double startX = coordinates.Item1;
        double startY = coordinates.Item2;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance(string coordinates)
    {
        double startX = Convert.ToDouble(coordinates.Split(",")[0]);
        double startY = Convert.ToDouble(coordinates.Split(",")[1]);

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }

}



public class Program
{

    static void Main()
    {

        Point distance = new Point(5, 5);

        distance.GetDistance("10, 10");
        Console.WriteLine();
        distance.GetDistance((10, 10));
        Console.WriteLine();
        distance.GetDistance(10, 10);

        Console.ReadKey();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface ICalculateDistance
{
    void GetDistance(double startX, double startY);
    void GetDistance((double, double) coordinates);
    void GetDistance(string coordinates);
}
public class Point : ICalculateDistance
{
    public double X {  get; set; }
    public double Y { get; set; }

    public Point(double endX, double endY)
    {
        X = endX; 
        Y = endY;
    }
    public Point ((double, double) coordinates)
    {
        X = coordinates.Item1;
        Y = coordinates.Item2;
    }
    public Point (string coordinates)
    {
        X = Convert.ToDouble(coordinates.Split(",")[0]);
        Y = Convert.ToDouble(coordinates.Split(",")[1]);
    }

    public void GetDistance(double startX, double startY)
    {
        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance((double, double) coordinates)
    {
        double startX = coordinates.Item1;
        double startY = coordinates.Item2;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }
    public void GetDistance(string coordinates)
    {
        double startX = Convert.ToDouble(coordinates.Split(",")[0]);
        double startY = Convert.ToDouble(coordinates.Split(",")[1]);

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        Console.WriteLine($"The distance is {distance}");
    }

    public double GetDistance(int startXcoord, int startYcoord)
    {
        double startX = startXcoord;
        double startY = startYcoord;

        double distance = Math.Sqrt(
            Math.Pow((X - startX), 2) +
            Math.Pow((Y - startY), 2)
            );

        return distance;
    }

}


public class Engine
{
    public string Type { get; set; }

    public Engine(string type) { Type = type; }

    public virtual void Move()
    {
        Console.WriteLine("The ship is moving.");
    }
}

public class ManeuveringEngine : Engine
{
    private Random random = new Random();
    private string[] _movements = new string[] { "→", "←", "↑", "↓" };
    private string _currentMovement;
    public ManeuveringEngine() : base("Maneuvering Engine") { _currentMovement = _movements[2]; }

    public override void Move()
    {
        string randomMovement = _currentMovement;
        while (randomMovement == _currentMovement)
        {
            randomMovement = _movements[random.Next(0, _movements.Length)];
        }

        Console.WriteLine($"{Type}: Ship is rotating from {_currentMovement} to {randomMovement}");
        _currentMovement = randomMovement;
    }
}

public class SustainingEngine : Engine
{
    private double _distance;

    public SustainingEngine() : base("Sustaining Engine") { _distance = 0; }
    public SustainingEngine(double distance) : base("Sustaining Engine") { if (distance > 0) _distance = distance; else _distance = 0; }


    public override void Move()
    {
        while (_distance > 0)
        {
            _distance--;
            if(_distance < 0) _distance = 0;

            Console.WriteLine($"{Type}: Ship is moving. Remaining distance: {_distance}");

        }
    }
}

public class JumpingEngine : Engine
{
    private double _distance;

    public JumpingEngine() : base("Jumping Engine") { _distance = 0; }
    public JumpingEngine(double distance) : base("Jumping Engine") { if (distance > 0) _distance = distance; else _distance = 0; }


    public override void Move()
    {
        while (_distance > 0)
        {
            _distance -= 5;
            if (_distance < 0) _distance = 0;

            Console.WriteLine($"{Type}: Ship is moving. Remaining distance: {_distance}");

        }
    }
}




public class HandleLoop
{
    public static void ActivateMove(List<Engine> engines)
    {
        foreach (Engine engine in engines) engine.Move();
    }
}

public class Program
{

    static void Main()
    {
        Point distance = new Point(5, 5);

        List<Engine> engines = new List<Engine>()
        {
            new ManeuveringEngine(),
            new SustainingEngine(distance.GetDistance(30, 20)),
            new JumpingEngine(distance.GetDistance(30, 20))

        };

        HandleLoop.ActivateMove(engines);

        Console.ReadKey();
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Medium

Task 3
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

interface IShape
{
    void Draw();
}

public class NavigationTable : IShape
{
    private Random random = new Random();
    private int[,] _field;
    private int Size { get; }

    public NavigationTable()
    {
        Size = 20;
        _field = new int[Size, Size];
        PopulateField();
    }


    private void PopulateField()
    {
        // getting min and max size for impassable
        int minImpassable = (int)(Size * Size * 0.05);
        int maxImpassable = (int)(Size * Size * 0.2);
        // randomly chosing between min and max value
        int impassableCounter = random.Next(minImpassable, maxImpassable + 1);

        // filling up all cells with passable value
        ClearField();

        // randomly changing cells to impassable until it reaches the impassable counter
        int counter = 0;

        while (counter < impassableCounter)
        {
            int x = random.Next(0, Size);
            int y = random.Next(0, Size);

            if (_field[x, y] == 0)
            {
                _field[x, y] = 1;
                counter++;
            }
        }
    }

    private void ClearField()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                _field[i, j] = 0;
            }
        }
    }

    public void Draw()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                Console.Write($" {_field[i, j]} ");
            }
            Console.WriteLine();
        }
    }

    public void Move(char direction)
    {
        int newY;
        int newX;

        switch (direction)
        {
            case 'W':
                {
                    newY = -1;
                    newX = 0;
                }
                break;
            case 'A':
                {
                    newY = 0;
                    newX = -1;
                }
                break;
            case 'S':
                {
                    newY = 1;
                    newX = 0;
                }
                break;
            case 'D':
                {
                    newY = 0;
                    newX = 1;
                }
                break;
            default:
                {
                    newY = 0;
                    newX = 0;
                }
                break;
        }

        // storing the current positions in a list
        List<(int y, int x)> currentPositions = new List<(int y, int x)>();

        for(int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                if (_field[i, j] == 1)
                {
                    currentPositions.Add((i, j));
                }
            }
        }

        // clearing the field
        ClearField();

        foreach ((int y, int x) in currentPositions)
        {
            int nextY = y + newY;
            int nextX = x + newX;

            if (nextY < 0) nextY = Size-1;
            if (nextX < 0) nextX = Size-1;
            if (nextY > Size - 1) nextY = 0;
            if (nextX > Size - 1) nextX = 0;

            _field[nextY, nextX] = 1;

        }





    }


}





public class HandleLoop
{

    private NavigationTable _table;

    public HandleLoop()
    {
        _table = new NavigationTable();
    }

    public void Play()
    {
        bool play = true;

            while (play)
            {

                Console.Clear();

                _table.Draw();

                Console.Write("Next direction: ");
                char direction = Convert.ToChar(Console.ReadLine().Trim().ToUpper());

                if (direction == 'Q') play = false;

                _table.Move(direction);

            }
    }


}

class Program
{
    static void Main()
    {
        HandleLoop loop = new HandleLoop();

        loop.Play();

        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 4
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

public abstract class Ship
{
    public int FuelTankSize {  get; }
    public int CurrentFuelLevel { get; set; }
    public List<Engine> Engines { get; set; }

    public Ship(int fuelTankSize, int fuelLevel, List<Engine> engines)
    {
        FuelTankSize = fuelTankSize;
        Engines = engines;
        CurrentFuelLevel = fuelLevel;
    }

    public abstract void ChangeFuelLevel();
}

public class Proud : Ship
{
    public Proud(int fuelTankSize, int fuelLevel, List<Engine> engines) : base(fuelTankSize, fuelLevel, engines) { }

    public override void ChangeFuelLevel()
    {
        foreach (Engine engine in Engines)
        {
            if (engine.Type == "Maneuvering")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per turn.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Maneuvering not possible: Insufficient fuel level.");
            }
            else if (engine.Type == "Sustaining")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per unit of distance traveled.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Insufficient fuel.");
            }
            else if (engine.Type == "Jumping")
            {
                if (CurrentFuelLevel > engine.Consumption)
                {
                    Console.WriteLine($"{engine.Type} engine: Consumes {engine.Consumption} unit of fuel per jump.");
                    CurrentFuelLevel -= engine.Consumption;
                }
                else Console.WriteLine("Jumping not possible: Insufficient fuel level.");
            }
        }
    }
}

public class Engine
{
    public string Type { get; }
    public int Consumption { get; }
    public Engine(string type)
    {
        Type = type;

        if (type == "Jumping") Consumption = 100;
        else if (type == "Sustaining") Consumption = 10;
        else Consumption = 1;
    }
}




public class HandleTask
{
    private Proud _proud;
    private List<Engine> _engines;

    public HandleTask()
    {
        _engines = new List<Engine>();
        CreateEngines();
        _proud = new Proud(200, 150, _engines);
    }

    private void CreateEngines()
    {
        _engines.Add(new Engine("Maneuvering"));
        _engines.Add(new Engine("Sustaining"));
        _engines.Add(new Engine("Jumping"));
        _engines.Add(new Engine("Jumping"));
    }

    public void CallChangeFuelLevel()
    {
        _proud.ChangeFuelLevel();
    }


}

class Program
{
    static void Main()
    {
        HandleTask task = new HandleTask();

        task.CallChangeFuelLevel();

        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Hard

Task 5
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

public struct Coordinates
{
    public int X {  get; set; }
    public int Y { get; set; }
    public Coordinates(int x, int y)
    {
        X = x; 
        Y = y;
    }
}

interface IRoute
{
    void MoveShip();
}

public class StarMap
{
    private Random random = new Random();
    private int[,] _field;
    public int Size { get; }
    public Coordinates EndCoordinate { get; set; }

    public StarMap()
    {
        Size = 20;
        EndCoordinate = new Coordinates(Size - 1, Size - 1);
        _field = new int[Size, Size];
        PopulateField();
    }

    private void PopulateField()
    {
        // getting min and max size for impassable
        int minImpassable = (int)(Size * Size * 0.05);
        int maxImpassable = (int)(Size * Size * 0.2);
        // randomly chosing between min and max value
        int impassableCounter = random.Next(minImpassable, maxImpassable + 1);

        // filling up all cells with passable value
        ClearField();

        // randomly changing cells to impassable until it reaches the impassable counter
        int counter = 0;

        // adding an extra obstacle to test jumping
        _field[10, 0] = 1;

        while (counter < impassableCounter)
        {
            int x = random.Next(0, Size);
            int y = random.Next(0, Size);

            // Filtering out the firt and end coordinate
            if (x != 0 && y != 0 && x != Size - 1 && y != Size - 1)
            {
                if (_field[x, y] == 0)
                {
                    _field[x, y] = 1;
                    counter++;
                }
            }
        }
    }

    private void ClearField()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                _field[i, j] = 0;
            }
        }
    }

    public bool Passable(int x, int y)
    {
        if (_field[y, x] == 0) return true;
        else return false;
    }

    public void Draw(int shipX, int shipY)
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                if(i == shipY && j == shipX)
                {
                    Console.Write(" S ");
                }
                else
                {
                    Console.Write($" {_field[i, j]} ");
                }
            }
            Console.WriteLine();
        }
    }


}

public class Proudy : IRoute
{
    private Coordinates _currentCoordinates;
    public string Name { get; }
    public int FuelLevel { get; set; }
    private int _jumpengineConsumption { get; }
    private int _engineConsumption { get; }
    private List<(int x, int y)> _possibleRoutes;
    private StarMap _map;
    public bool _finished;
    private List<string> _movementsLog {  get; set; }

    public Proudy(StarMap map)
    {
        _movementsLog = new List<string>();
        _currentCoordinates = new Coordinates(0, 0);
        _possibleRoutes = new List<(int x, int y)>() { (1, 0), (0, 1), (-1, 0), (0, -1)};
        _engineConsumption = 1;
        _jumpengineConsumption = 10;
        Name = "Proudy";
        FuelLevel = 100;
        _map = map;
        _finished = false;
    }

    private void MoveShipWithBaseEngine()
    {
        double currentDistance = CalculateDistance(_currentCoordinates.X, _currentCoordinates.Y, _map.EndCoordinate.X, _map.EndCoordinate.Y);

        Coordinates nextCoordinates = _currentCoordinates;

        // move ship with base engine
        for ( int i = 0; i < _possibleRoutes.Count; i++)
        {
            int nextX = _currentCoordinates.X + _possibleRoutes[i].x;
            int nextY = _currentCoordinates.Y + _possibleRoutes[i].y;

            // checking for boundaries
            if (nextX < 0 || nextY < 0 || nextX >= _map.Size || nextY >= _map.Size)
            {
                continue;
            }
                // checking if it's passable or not
            if (_map.Passable(nextX, nextY))
            {
                double nextDistance = CalculateDistance(nextX, nextY, _map.EndCoordinate.X, _map.EndCoordinate.Y);
                // checking the distances
                if(nextDistance < currentDistance)
                {
                    nextCoordinates.X = nextX;
                    nextCoordinates.Y = nextY;
                }
            }
        }

        // removing the fuel
        FuelLevel -= _engineConsumption;

        // adding the movement to the list with the symbol
        string symbol = GetSymbol(_currentCoordinates.X, _currentCoordinates.Y, nextCoordinates.X, nextCoordinates.Y);
        _movementsLog.Add($"Proudy moves {symbol} from {_currentCoordinates.X}-{_currentCoordinates.Y} to {nextCoordinates.X}-{nextCoordinates.Y}, current fuel level: {FuelLevel}L");

        // setting the new coordinates
        _currentCoordinates = nextCoordinates;

        // checking if destination is reached, then adding the text to the log
        if (_currentCoordinates.X == _map.EndCoordinate.X && _currentCoordinates.Y == _map.EndCoordinate.Y)
        {
            _movementsLog.Add($"\nProudy has reached the destination. Reamining fuel: {FuelLevel}L");
        }

    }
    public void MoveShip()
    {
        double currentDistance = CalculateDistance(_currentCoordinates.X, _currentCoordinates.Y, _map.EndCoordinate.X, _map.EndCoordinate.Y);
        double nextDistance = currentDistance;

        Coordinates nextCoordinates = _currentCoordinates;
        Coordinates controlCoordinates = _currentCoordinates;

        int modifieX = 0;
        int modifieY = 0;

        // going through all the possible routes
        for (int i = 0; i < _possibleRoutes.Count; i++)
        {
            int nextX = _currentCoordinates.X + _possibleRoutes[i].x;
            int nextY = _currentCoordinates.Y + _possibleRoutes[i].y;

            // checking for boundaries
            if (nextX < 0 || nextY < 0 || nextX >= _map.Size || nextY >= _map.Size)
            {
                continue;
            }

            // calculating the distance for the next move
            nextDistance = CalculateDistance(nextX, nextY, _map.EndCoordinate.X, _map.EndCoordinate.Y);

            // checking the distances
            if (nextDistance < currentDistance)
            {
                nextCoordinates.X = nextX;
                nextCoordinates.Y = nextY;
                // saving the direction
                modifieX = _possibleRoutes[i].x;
                modifieY = _possibleRoutes[i].y;
            }
        }

        // checking if distance is not the same as currentdistance and if fuel level is over 30
        if (currentDistance != nextDistance && FuelLevel > 30)
        {
            // checking if it's not impassable
            if (!_map.Passable(nextCoordinates.X, nextCoordinates.Y))
            {
                // checking if next coordinate is passable in the same direction
                int jumpX = nextCoordinates.X + modifieX;
                int jumpY = nextCoordinates.Y + modifieY;

                if ( jumpX >= 0 && jumpX < _map.Size && jumpY >= 0 && jumpY < _map.Size && _map.Passable(jumpX, jumpY))
                {
                    FuelLevel -= _jumpengineConsumption;
                    string symbol = GetSymbol(_currentCoordinates.X, _currentCoordinates.Y, jumpX, jumpY);
                    _movementsLog.Add($"Proudy moves {symbol} from {_currentCoordinates.X}-{_currentCoordinates.Y} to {jumpX}-{jumpY} with the jump engine, current fuel level: {FuelLevel}L");
                    _currentCoordinates.X = jumpX;
                    _currentCoordinates.Y = jumpY;

                    // checking if destination is reached, then adding the text to the log
                    if (_currentCoordinates.X == _map.EndCoordinate.X && _currentCoordinates.Y == _map.EndCoordinate.Y)
                    {
                        _movementsLog.Add($"\nProudy has reached the destination. Reamining fuel: {FuelLevel}L");
                    }

                    // exiting the function, so MoveShipWithBaseEngine not called
                    return;
                }
            }
        }

        // calling the baseengine movement if jumping is not possible
        MoveShipWithBaseEngine();
    }

    private double CalculateDistance(int currentX, int currentY, int endX, int endY)
    {
        double distance = Math.Sqrt(
            Math.Pow(endX - currentX, 2) +
            Math.Pow(endY - currentY, 2)
            );

        return distance;
    }

    public int GetCurrentXCoordinate()
    {
        return _currentCoordinates.X;
    }
    public int GetCurrentYCoordinate()
    {
        return _currentCoordinates.Y;
    }

    private string GetSymbol(int currX, int currY, int nextX, int nextY)
    {
        string symbol = "";

        if (currX != nextX)
        {
            if (currX < nextX) symbol = "→";
            else symbol = "←";
        }
        else if(currY != nextY)
        {
            if (currY < nextY) symbol = "↓";
            else symbol = "↑";
        }
            return symbol;
    }

    public void DisplayMovements()
    {
        foreach (string entry in _movementsLog)
        {
            Console.WriteLine(entry);
        }
    }

}

public class HandleTask
{
    private Proudy _ship;
    private StarMap _map;

    public HandleTask(Proudy ship, StarMap map)
    {
        _ship = ship;
        _map = map;
    }

    public void Run()
    {
        while (!_ship._finished && _ship.FuelLevel > 0)
        {
            _ship.MoveShip();

            if (_ship.GetCurrentXCoordinate() == _map.EndCoordinate.X && _ship.GetCurrentYCoordinate() == _map.EndCoordinate.Y)
            {
                _ship._finished = true;
            }
        }

        _map.Draw(0, 0);
        Console.WriteLine();
        _ship.DisplayMovements();

    }

}


class Program
{

    static void Main()
    {

        StarMap map = new StarMap();
        Proudy ship = new Proudy(map);

        HandleTask sim = new HandleTask(ship, map);

        sim.Run();

        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 6
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;

public struct Coordinates
{
    public int X {  get; set; }
    public int Y { get; set; }
    public Coordinates(int x, int y)
    {
        X = x; 
        Y = y;
    }
}

interface IRoute
{
    void MoveShip();
}
interface IShape
{
    void Draw();
}

public class StarMap
{
    private Random random = new Random();
    private int[,] _field;
    public int Size { get; }
    public Coordinates EndCoordinate { get; set; }

    public StarMap()
    {
        Size = 20;
        EndCoordinate = new Coordinates(Size - 1,Size - 1);
        _field = new int[Size, Size];
        PopulateField();
        GetEndCoordinate();
    }

    private void PopulateField()
    {
        // getting min and max size for impassable
        int minImpassable = (int)(Size * Size * 0.05);
        int maxImpassable = (int)(Size * Size * 0.2);
        // randomly chosing between min and max value
        int impassableCounter = random.Next(minImpassable, maxImpassable + 1);

        // filling up all cells with passable value
        ClearField();

        // randomly changing cells to impassable until it reaches the impassable counter
        int counter = 0;

        // adding an extra obstacle to test jumping
        _field[10, 0] = 1;

        while (counter < impassableCounter)
        {
            int x = random.Next(0, Size);
            int y = random.Next(0, Size);

            // Filtering out the firt and end coordinate
            if (x != 0 && y != 0 && x != Size - 1 && y != Size - 1)
            {
                if (_field[x, y] == 0)
                {
                    _field[x, y] = 1;
                    counter++;
                }
            }
        }
    }

    private void ClearField()
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                _field[i, j] = 0;
            }
        }
    }

    public bool Passable(int x, int y)
    {
        if (_field[y, x] == 0) return true;
        else return false;
    }

    public void Draw(int shipX, int shipY, string symbol)
    {
        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                if(i == shipY && j == shipX)
                {
                    Console.Write($" {symbol} ");
                }
                else
                {
                    Console.Write($" {_field[i, j]} ");
                }
            }
            Console.WriteLine();
        }
    }

    public void GetEndCoordinate()
    {
        Console.WriteLine("Enter the destination coordinates:");

        while (true)
        {
            try
            {
                Console.Write("X: ");
                int x = Convert.ToInt32(Console.ReadLine().Trim());

                Console.Write("Y: ");
                int y = Convert.ToInt32(Console.ReadLine().Trim());

                if(Passable(x, y) && x >= 0 && y >= 0 && x < Size && y < Size)
                {
                    Coordinates current = new Coordinates(x, y);
                    EndCoordinate = current;
                    return;
                }
                else
                {
                    Console.WriteLine("Selected Coordinates are impassable objects");
                }

            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
    }

}

public class Proudy : IRoute, IShape
{
    private Coordinates _currentCoordinates;
    public string Name { get; }
    public int FuelLevel { get; set; }
    private int _jumpengineConsumption { get; }
    private int _engineConsumption { get; }
    private List<(int x, int y)> _possibleRoutes;
    private StarMap _map;
    public bool _finished;
    private string _currentSymbol {  get; set; }

    public Proudy(StarMap map)
    {
        _currentCoordinates = new Coordinates(0, 0);
        _possibleRoutes = new List<(int x, int y)>() { (1, 0), (0, 1), (-1, 0), (0, -1)};
        _engineConsumption = 1;
        _jumpengineConsumption = 10;
        Name = "Proudy";
        FuelLevel = 100;
        _map = map;
        _finished = false;
        _currentSymbol = "P";
    }

    private void MoveShipWithBaseEngine()
    {
        double currentDistance = CalculateDistance(_currentCoordinates.X, _currentCoordinates.Y, _map.EndCoordinate.X, _map.EndCoordinate.Y);

        Coordinates nextCoordinates = _currentCoordinates;

        // move ship with base engine
        for ( int i = 0; i < _possibleRoutes.Count; i++)
        {
            int nextX = _currentCoordinates.X + _possibleRoutes[i].x;
            int nextY = _currentCoordinates.Y + _possibleRoutes[i].y;

            // checking for boundaries
            if (nextX < 0 || nextY < 0 || nextX >= _map.Size || nextY >= _map.Size)
            {
                continue;
            }
                // checking if it's passable or not
            if (_map.Passable(nextX, nextY))
            {
                double nextDistance = CalculateDistance(nextX, nextY, _map.EndCoordinate.X, _map.EndCoordinate.Y);
                // checking the distances
                if(nextDistance < currentDistance)
                {
                    nextCoordinates.X = nextX;
                    nextCoordinates.Y = nextY;
                }
            }
        }

        // removing the fuel
        FuelLevel -= _engineConsumption;

        // getting the current symbol
        _currentSymbol = GetSymbol(_currentCoordinates.X, _currentCoordinates.Y, nextCoordinates.X, nextCoordinates.Y);
        

        // setting the new coordinates
        _currentCoordinates = nextCoordinates;


    }
    public void MoveShip()
    {
        double currentDistance = CalculateDistance(_currentCoordinates.X, _currentCoordinates.Y, _map.EndCoordinate.X, _map.EndCoordinate.Y);
        double nextDistance = currentDistance;

        Coordinates nextCoordinates = _currentCoordinates;
        Coordinates controlCoordinates = _currentCoordinates;

        int modifieX = 0;
        int modifieY = 0;

        // going through all the possible routes
        for (int i = 0; i < _possibleRoutes.Count; i++)
        {
            int nextX = _currentCoordinates.X + _possibleRoutes[i].x;
            int nextY = _currentCoordinates.Y + _possibleRoutes[i].y;

            // checking for boundaries
            if (nextX < 0 || nextY < 0 || nextX >= _map.Size || nextY >= _map.Size)
            {
                continue;
            }

            // calculating the distance for the next move
            nextDistance = CalculateDistance(nextX, nextY, _map.EndCoordinate.X, _map.EndCoordinate.Y);

            // checking the distances
            if (nextDistance < currentDistance)
            {
                nextCoordinates.X = nextX;
                nextCoordinates.Y = nextY;
                // saving the direction
                modifieX = _possibleRoutes[i].x;
                modifieY = _possibleRoutes[i].y;
            }
        }

        // checking if distance is not the same as currentdistance and if fuel level is over 30
        if (currentDistance != nextDistance && FuelLevel > 30)
        {
            // checking if it's not impassable
            if (!_map.Passable(nextCoordinates.X, nextCoordinates.Y))
            {
                // checking if next coordinate is passable in the same direction
                int jumpX = nextCoordinates.X + modifieX;
                int jumpY = nextCoordinates.Y + modifieY;

                if ( jumpX >= 0 && jumpX < _map.Size && jumpY >= 0 && jumpY < _map.Size && _map.Passable(jumpX, jumpY))
                {
                    // adjusting the fuel level
                    FuelLevel -= _jumpengineConsumption;
                    // getting the current symbol
                    _currentSymbol = GetSymbol(_currentCoordinates.X, _currentCoordinates.Y, jumpX, jumpY);

                    _currentCoordinates.X = jumpX;
                    _currentCoordinates.Y = jumpY;

                    // exiting the function, so MoveShipWithBaseEngine not called
                    return;
                }
            }
        }

        // calling the baseengine movement if jumping is not possible
        MoveShipWithBaseEngine();
    }

    private double CalculateDistance(int currentX, int currentY, int endX, int endY)
    {
        double distance = Math.Sqrt(
            Math.Pow(endX - currentX, 2) +
            Math.Pow(endY - currentY, 2)
            );

        return distance;
    }

    public int GetCurrentXCoordinate()
    {
        return _currentCoordinates.X;
    }
    public int GetCurrentYCoordinate()
    {
        return _currentCoordinates.Y;
    }

    private string GetSymbol(int currX, int currY, int nextX, int nextY)
    {
        string symbol = "";

        if (currX != nextX)
        {
            if (currX < nextX) symbol = "→";
            else symbol = "←";
        }
        else if(currY != nextY)
        {
            if (currY < nextY) symbol = "↓";
            else symbol = "↑";
        }
            return symbol;
    }

    public void Draw()
    {
        while (!_finished && FuelLevel > 0)
        {
            Console.Clear();

            MoveShip();

            if (GetCurrentXCoordinate() == _map.EndCoordinate.X && GetCurrentYCoordinate() == _map.EndCoordinate.Y) _finished = true;

            _map.Draw(GetCurrentXCoordinate(), GetCurrentYCoordinate(), _currentSymbol);

            // Displaying the distance to the target.
            double distance = CalculateDistance(_currentCoordinates.X, _currentCoordinates.Y, _map.EndCoordinate.X, _map.EndCoordinate.Y);
            Console.WriteLine($"Current distance to the target: {Math.Round(distance, 2)} unit");

            Console.ReadKey();
        }

        if (GetCurrentXCoordinate() == _map.EndCoordinate.X && GetCurrentYCoordinate() == _map.EndCoordinate.Y) Console.WriteLine("\nProudy reached the destination");

        if (FuelLevel <= 0 && GetCurrentXCoordinate() != _map.EndCoordinate.X && GetCurrentYCoordinate() != _map.EndCoordinate.Y) Console.WriteLine("Proudy can not reached the destination, out of fuel.");
    }

}





class Program
{

    static void Main()
    {

        StarMap map = new StarMap();
        Proudy ship = new Proudy(map);

        ship.Draw();


        Console.ReadKey();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Task 7
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

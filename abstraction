
Briefing

Returning to the ship, Captain Freeman whistled contentedly, smiling more than usual. 
When he saw you and the sergeant keeping watch at the airlock,
his smile widened and began to resemble that of a well-fed and contented shark.

    Trainee, I entrust you, as the senior and only member of the watch,
with sorting out the purchases that I collected for the ship and crew.

And whistling something brave, the captain retreated into the depths of the ship. 
You turned your gaze to where the sergeant should have been to clarify 
the order of actions with the senior rank, but he was not there. 
Apparently, the sergeant, accustomed to the captain’s sudden ideas and orders,had disappeared.
Robots continued to enter the airlock and pile up the captain’s purchases into an ever-growing heap.

You decide that you first need to understand what the captain bought and go to explore the stack of boxes.
You decide to write a program for the robots to help you distribute the purchases to the correct places.


Difficulty level - EASY

Task #1

First, you need to identify the categories, or in other words, the classes to which the purchases belong.
Each team chooses one category to work on for the following tasks.

In the pile of purchases, you see: 
oranges, apples, tables, chairs, plums, grapes, lentils, screwdrivers, 
hammers, pliers, several dozen coils of cable, sheathing sheets, door handles,
mice, keyboards, holoscreens, games, poultry, salmon, pike, herring, potatoes, rice, 
frying pans, pots, gunpowder, charges for guns, a couple of torpedoes, 
about three dozen first aid kits, about forty boxes, a mountain of shoes,
a whole container of naval uniforms of various types, androids, and probably a wagon of containers with unigel.

The answer to the task should be given in the form of class names describing purchase groups.

Expected Input:

There is no direct input for this task. Instead, we are categorizing the items directly within the Main method. 
These items are part of the program as hardcoded categories.

Expected Output:

After running the program, we should expect to see a message categorizing the purchases into the following groups:

The categories of purchases are as follows:
Food: Oranges, Apples, Plums, Grapes, Lentils, Rice, Potatoes, etc.
Furniture: Tables, Chairs, etc.
Tools: Screwdrivers, Hammers, Pliers, etc.
Clothing: Naval uniforms, Shoes, etc.
Electronics: Mice, Keyboards, Holoscreens, etc.
Weapons: Gunpowder, Charges for Guns, Torpedoes, etc.
Medical: First Aid Kits.
Toys: Games.
Fish: Salmon, Pike, Herring.
Miscellaneous: Containers with Unigel, Boxes, etc.

Implementation Details

To solve this task, we will define several classes that represent different categories of purchases.
Each class will describe a distinct group of items from the list provided in the prompt. 
Since no properties or abstract classes are allowed, we will simply create class names and organize the items logically.
We will assign each category of items into an appropriate class, based on their type.

    Define categories for purchases: We will group the items into categories such as Food, Furniture, Tools, Clothing, Electronics, Weapons, Medical, Toys, Fish, and Miscellaneous.

    Create simple classes: Each class will be an empty class representing a category. 
	We will only use the class names for categorization, as there will be no need for properties or methods in this task.

    Organize items into classes: Based on the items in the list, we will decide which class they belong to. For example:

        Food category will include items like oranges, apples, lentils, etc.

        Furniture will include tables, chairs, etc.

        Tools will include items like screwdrivers, hammers, pliers, etc.

        Medical will include first aid kits.

        And so on for each category.

    Program Structure:

        Create each category class.

        Create a Main method that demonstrates the classification of items into these categories.

Task #2

Having identified the classes from this mountain of purchases, 
you need to understand what characterizes them and distinguishes them from others. 
For each class selected in the previous task, select the maximum number of fields and methods from the table below.

Length        			Bite()            			Paint()    		 			Size              		Strike()                Number of handles
	
Width         			Chew grass()      			Spin()      				Quantity         		Number of eyes          Explode()

Height        			Swim()            			Chew()      				Amount           		Number of grains        Hit target()

Weight        			Orange            			Unscrew()   				TNT equivalent    		Number of carcasses     Fire()

Weight        			Color             			Curl()      				Treat()          		Quantity                Availability of fillet
	
Color		  			Blue			  		 	Protect()	  				To give first aid()		Warhead weight			Foot size

Number of fins			Red				 			Number of keys				Hit the nail()			Type of explosive		Chest size

Run()					White			 		 	Volume						Beat()					Number of handles		Height

Hip girth				Leg length		  		 	Purpose						Functional				Walk()					Run()

Display image()			Manipulate something()	 	Left Click()				Right Click()			Ride()					Slide()

Container volume		Weight without container 	Volume without packaging	Top color				Bottom color			Rank marks

Number of boxes			Number of bays				Cable type					Metal					Armor type				Kosher

Number of containers	Number of bags				Wear()						Own()					Green					Water

Habitat					Air							Left						Right					Sole type				Wear()

Material				Fastener type				zip()						Dress()					Laces					Leather

Plastics				Plastic						Rubber						Synthetic fabric		Nylon					Capron

Caliber					Damage range				Scattering					engine’s type			Fly()					Explode()

Live					Dead						Frozen						Fresh					Long storage			Cooking type

Necessary tool			Necessary consumables		Place of application		Destination compartment	Kitchen					Engineering

Pantry					Chopping					Bridge						Sickbay					Hold					Conning tower

	
Expected Input:

There is no direct input in the program. 
Instead, we are categorizing and associating items with the fields and methods in the Main method. 
The categories were set earlier based on the items in the purchase pile.

Expected Output:

The expected output would describe the categories and the fields and methods associated with them. 
It might look something like this:

Food Category:
Fields: Weight, Color, Quantity, Amount, Size, Fresh, Long storage, Cooking type
Methods: Chew(), Swim(), Chew grass(), To give first aid(), Treat(), Freeze()

Furniture Category:
Fields: Height, Width, Length, Number of handles, Weight, Material
Methods: Manipulate something(), Move(), Spin()

Tools Category:
Fields: Weight, Size, Number of handles, Purpose
Methods: Strike(), Hit target(), Unscrew()

Clothing Category:
Fields: Size, Color, Material, Foot size, Number of buttons, Laces, Sole type
Methods: Wear(), Dress(), Laces(), Zip()

Electronics Category:
Fields: Weight, Color, Number of keys, Size, Purpose
Methods: Left Click(), Right Click(), Display image()

Weapons Category:
Fields: Weight, Damage range, Scattering, TNT equivalent, Warhead weight, Caliber
Methods: Explode(), Fire(), Strike()

Medical Category:
Fields: Weight, Quantity, Type of explosive, Color
Methods: Treat(), To give first aid()

Toys Category:
Fields: Weight, Size, Color, Quantity, Purpose
Methods: Manipulate something(), Play()

Fish Category:
Fields: Weight, Color, Number of fins, Length
Methods: Swim(), Live(), Fresh()

Miscellaneous Category:
Fields: Weight, Quantity, Volume, Material, Size
Methods: Wear(), Move(), Slide()

Implementation Details:

For each category class (created in the previous task), we will:

    Identify the characteristics of the items in the category (based on their nature).

    Select the most appropriate fields and methods from the list of available options to describe each category.

    Associate fields that describe specific properties (like Weight, Quantity, etc.),
		and methods that describe actions (like Explode(), Swim(), etc.).


Difficulty level - MEDIUM

Task #3

Consider the classes created in the last task and remove everything unnecessary, 
leaving the minimum required set of methods and fields. 
This set must fully describe the class so that it can be distinguished from any other. 
For all remaining and deleted fields and methods,prepare an explanation of why each was kept or removed.
If necessary, add missing fields and methods and justify their inclusion.

Expected Input:

    Constructor Parameters:

        For each category, we will use the constructor to initialize the fields like Weight, Color, Purpose, etc.

        Example input might look like:

            Food constructor might receive parameters like "2kg", "Green", true (for fresh).

            Furniture constructor might receive parameters like "2m", "Wood", etc.

Constructor examples:

public Food(string weight, string color, bool fresh)

public Furniture(string height, string material)

Expected Output:

After running the program, the output will print the fields and methods for each category class as described in the Main method.

Console Output Example:

The categories of purchases are as follows:

Food Category:
Fields: Weight, Color, Fresh
Methods: Chew(), Freeze()

Furniture Category:
Fields: Height, Width, Material
Methods: Move(), Spin()

Tools Category:
Fields: Weight, Size, Purpose
Methods: Strike(), Unscrew()

Clothing Category:
Fields: Size, Color, Material
Methods: Wear(), Zip()

Electronics Category:
Fields: Weight, Color, Purpose
Methods: Left Click(), Display image()

Weapons Category:
Fields: Weight, Damage range, Caliber
Methods: Fire(), Strike()

Medical Category:
Fields: Weight, Color
Methods: Treat(), Give first aid()

Toys Category:
Fields: Weight, Size, Purpose
Methods: Play()

Fish Category:
Fields: Weight, Color, Number of fins
Methods: Swim(), Fresh()

Miscellaneous Category:
Fields: Weight, Quantity, Material
Methods: Move(), Slide()

Implementation Details

    Identify Necessary Fields and Methods for Each Class:

        We need to keep only the essential fields and methods that fully describe each category, ensuring that each class is distinct and its functionality is clear.

        Fields and methods that don’t provide unique or useful information for distinguishing the class can be removed.

    Decide Which Fields to Keep:

        The fields should be essential to the core definition of each category. For example, the Food class may require Weight, Color, Size, and Fresh to distinguish different types of food.

        Other fields that don’t add unique value, such as Amount, LongStorage, and CookingType in the Food class, may be removed.

        Similarly, in the Furniture class, fields like Height, Width, and Material are important to distinguish different furniture items, but other optional fields can be removed.

    Remove or Keep Methods:

        We need to remove any methods that don’t contribute to the functionality of the class or its description.

        For example, methods like Chew(), Swim(), and Freeze() in the Food category are not critical for its basic definition. We may keep only the method(s) that add significant value for distinguishing the class.

        Similarly, other methods like ManipulateSomething(), Strike(), etc., may be removed or kept based on their importance for each category.

    Justify the Fields and Methods to Keep:

        The remaining fields should represent the fundamental characteristics of each class.

        The remaining methods should reflect actions or behaviors that are logically tied to the class.

Task #4

Based on the created description, create a program that describes this class. All created methods must output something to the console, and all remaining fields must be used in more than one method.

Expected Input:

All fields for the classes (Food, Furniture, Tools, etc.) are initialized via constructors when creating the objects. These fields include Weight, Color, Material, Purpose, and other relevant details.

For example:

Food food = new Food("2kg", "Green", true);
Furniture furniture = new Furniture("2m", "Wood");

Expected Output:

After running the program, the output will consist of various console messages for each class, showing the results of the methods executed:

The food weighing 2kg and colored Green is being chewed.
The food weighing 2kg and colored Green is now frozen. Fresh: True
Food details - Weight: 2kg, Color: Green, Fresh: True
The furniture made of Wood with a height of 2m is being moved.
The Wood furniture is spinning. Height: 2m
Furniture details - Height: 2m, Material: Wood

Implementation Details:

    Define the classes based on the task description. We will create a set of classes (Food, Furniture, Tools, Clothing, Electronics, Weapons, Medical, Toys, Fish, and Miscellaneous). These classes will have fields initialized through their constructors and will contain methods that output to the console.

    Each class will have at least two fields, and each method will interact with these fields. All fields will be used in more than one method to fulfill the requirement.

    Create methods inside each class:

        For each class, create at least two methods that will output a message to the console using the fields of the class.

        Add a descriptive method for each class to print the values of the fields.

        Example: In the Food class, the Chew method outputs a message including the Weight and Color, and the Freeze method will also use these fields.

    In the Main method, create objects of each class, initialize them using their constructors, and then call the methods to display the output.

Difficulty level - HARD

Task #5

You need to develop a system for managing colonies on different planets. The system should handle resource management, buildings, colonists, and their needs.

Requirements:

    Class Colony:

        Fields: Id, Name, Planet (reference to Planet), Population, Resources (dictionary of resources), Buildings (collection of buildings).

        Methods: AddBuilding(Building building), AllocateResources(string resourceName, int amount), UpdatePopulation(int amount), GetColonyInfo().

    Class Building:

        Fields: Id, Name, Type, Capacity, ConstructionCost (dictionary of resources).

        Methods: Construct(), GetBuildingInfo().

    Class Resource:

        Fields: Name, Quantity.

        Methods: GetResourceInfo().

    Class Colonist:

        Fields: Id, Name, Role, Health, CurrentColony (reference to Colony).

        Methods: AssignToColony(Colony colony), UpdateHealth(int amount), GetColonistInfo().

    Class ColonyManager:

        Fields: Colonies (collection of colonies), Buildings (collection of buildings), Resources (collection of resources), Colonists (collection of colonists).

        Methods: CreateColony(Colony colony), BuildBuilding(int colonyId, Building building), ManageResources(int colonyId, string resourceName, int amount), AddColonistToColony(int colonyId, Colonist colonist).

Task:

    Implement the specified classes with the appropriate fields and methods.

    Write a program that demonstrates the system’s functionality: creating colonies, managing resources and buildings, assigning colonists, and displaying information about colonies and their status.

Expected Input:

    Planet name: "Earth"

    Colony name: "New Earth Colony"

    Building: "House", Type: "Residential", Capacity: 10

    Resource: "Water", Quantity: 1000

    Colonist: "John Doe", Role: "Farmer", Health: 100

Expected Output:

House is being constructed with a capacity of 10.
Colony ID: 1, Name: New Earth Colony, Population: 1, Resources: Water: 1000
Building ID: 1, Name: House, Type: Residential, Capacity: 10

Colonist ID: 1, Name: John Doe, Role: Farmer, Health: 100

Implementation Details:

To implement the system for managing colonies on different planets, we will need to follow the specified class structure. Each class will contain fields to store the relevant data and methods to handle the required operations.

Here’s a step-by-step breakdown of how to create and implement the classes and methods:

Step 1: Create the Colony Class:

    Fields:

        Id: A unique identifier for the colony.

        Name: The name of the colony.

        Planet: A reference to the planet the colony is on (we’ll create a Planet class later).

        Population: The number of people in the colony.

        Resources: A dictionary containing the available resources in the colony.

        Buildings: A collection of buildings in the colony.

    Methods:

        AddBuilding(Building building): Adds a building to the colony.

        AllocateResources(string resourceName, int amount): Allocates resources from the colony’s available stock.

        UpdatePopulation(int amount): Updates the population by adding or removing a specified number of colonists.

        GetColonyInfo(): Returns a string with detailed information about the colony (Id, Name, Population, and available resources).

Step 2: Create the Building Class:

    Fields:

        Id: A unique identifier for the building.

        Name: The name of the building.

        Type: The type of building (e.g., house, factory, etc.).

        Capacity: The capacity of the building (how many colonists or resources it can hold).

        ConstructionCost: A dictionary containing the required resources to build the building.

    Methods:

        Construct(): Simulates the construction process of the building.

        GetBuildingInfo(): Returns a string with detailed information about the building (Id, Name, Type, Capacity).

Step 3: Create the Resource Class:

    Fields:

        Name: The name of the resource (e.g., Water, Food, Energy, etc.).

        Quantity: The amount of the resource available in the colony.

    Methods:

        GetResourceInfo(): Returns a string with the name and quantity of the resource.

Step 4: Create the Colonist Class:

    Fields:

        Id: A unique identifier for the colonist.

        Name: The name of the colonist.

        Role: The role of the colonist (e.g., farmer, scientist, worker, etc.).

        Health: The health status of the colonist.

        CurrentColony: A reference to the current colony the colonist belongs to.

    Methods:

        AssignToColony(Colony colony): Assigns the colonist to a specific colony.

        UpdateHealth(int amount): Updates the health of the colonist (positive value increases health, negative value decreases health).

        GetColonistInfo(): Returns a string with detailed information about the colonist (Id, Name, Role, Health).

Step 5: Create the ColonyManager Class:

    Fields:

        Colonies: A collection of all the colonies.

        Buildings: A collection of all buildings available in the system.

        Resources: A collection of all the available resources.

        Colonists: A collection of all colonists.

    Methods:

        CreateColony(Colony colony): Adds a colony to the system.

        BuildBuilding(int colonyId, Building building): Builds a new building in a specific colony.

        ManageResources(int colonyId, string resourceName, int amount): Manages resources in a specific colony (allocates or gathers resources).

        AddColonistToColony(int colonyId, Colonist colonist): Assigns a colonist to a specific colony.

Step 6: Implement the Main Program:

In the main program, we’ll demonstrate the functionality of the system by creating colonies, managing resources and buildings, assigning colonists, and displaying information.
